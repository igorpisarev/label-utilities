package org.janelia.saalfeldlab.labels.blocks

import com.google.gson.annotations.Expose
import net.imglib2.FinalInterval
import net.imglib2.Interval
import net.imglib2.util.Intervals
import org.janelia.saalfeldlab.util.HashWrapper
import org.slf4j.LoggerFactory
import java.lang.invoke.MethodHandles
import java.nio.ByteBuffer
import java.nio.file.Files
import java.nio.file.Paths
import java.util.*

class LabelBlockLookupFromFile(@Expose private val pattern: String?) : LabelBlockLookup {

	companion object {
		private val LOG = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass())

		private val EMPTY_ARRAY = arrayOf<Interval>()

		// 3 : nDim
		// 2 : min and max
		private val SINGLE_ENTRY_BYTE_SIZE = 3 * 2 * java.lang.Long.BYTES

	}

	override fun apply(t: Long): Array<Interval> {
		if (pattern == null) {
			LOG.warn("Invalid pattern, returning empty array: {}", pattern)
			return EMPTY_ARRAY
		}

		val path = String.format(pattern, t)
		try {
			val bytes = Files.readAllBytes(Paths.get(path))
			if (!isValidByteSize(bytes.size)) {
				throw InvalidFileSize(bytes.size)
			}

			val intervals = HashSet<HashWrapper<Interval>>()

			val bb = ByteBuffer.wrap(bytes)

			while (bb.hasRemaining()) {
				intervals.add(HashWrapper.interval(FinalInterval(
						longArrayOf(bb.long, bb.long, bb.long),
						longArrayOf(bb.long, bb.long, bb.long)
				)))
			}

			return intervals
					.stream()
					.map<Interval> { it.data }
					.toArray { arrayOfNulls<Interval>(it) }

		} catch (e: Exception) {
			LOG.error(
					"Unable to read data from file at {} generated by pattern {} and id {} -- returning empty array: " + "{}",
					path, pattern, t,
					e.message
			)
			return EMPTY_ARRAY
		}

	}

	override fun accept(id: Long, intervals: Array<Interval>) {

		if (pattern == null) {
			LOG.info("Pattern is null, cannot write!")
			return
		}

		val numBytes = intervals.size * SINGLE_ENTRY_BYTE_SIZE
		val data = ByteArray(numBytes)
		val bb = ByteBuffer.wrap(data)
		for (t in intervals) {
			val l1 = Intervals.minAsLongArray(t)
			val l2 = Intervals.maxAsLongArray(t)
			bb.putLong(l1[0])
			bb.putLong(l1[1])
			bb.putLong(l1[2])
			bb.putLong(l2[0])
			bb.putLong(l2[1])
			bb.putLong(l2[2])
		}
		val p = Paths.get(String.format(pattern!!, id))
		Files.createDirectories(p.parent)
		Files.write(p, data)
	}

	private fun isValidByteSize(sizeInBytes: Int): Boolean {
		return sizeInBytes % SINGLE_ENTRY_BYTE_SIZE == 0
	}

	private class InvalidFileSize(sizeInBytes: Int) : Exception("Expected file size in bytes of integer multiple of " + SINGLE_ENTRY_BYTE_SIZE + " but got " +
			sizeInBytes) {
		companion object {

			/**
			 *
			 */
			private val serialVersionUID = 3063871520312958385L
		}

	}

}
